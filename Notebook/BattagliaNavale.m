(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["BattagliaNavale`"];*)
(**)
(*BattagliaNavaleGame::usage="Avvia il gioco della Battaglia Navale a turni.";*)
(*BinToDec::usage="BinToDec[s_String] converte una stringa binaria in un intero decimale.";*)
(**)
(*Begin["`Private`"];*)
(**)
(*(*********************************************************)*)
(*(*1) CONVERSIONI E MAPPATURA DELLE CELLE*)*)
(*(*********************************************************)*)
(**)
(*BinToDec[s_String]:=FromDigits[s,2]*)
(**)
(*gridSize=10;*)
(*debugPC=True;  (*Se True,le navi del PC (valore 1) vengono disegnate in nero*)*)
(**)
(*(*Mappa un intero (0..99) in coordinate {riga,colonna}.Convenzione:0->{10,10} (in basso a destra) 99->{1,1} (in alto a sinistra)*)*)
(*cellCoords[d_Integer]:={gridSize-Quotient[d,10],gridSize-Mod[d,10]}*)
(**)
(*(*********************************************************)*)
(*(*2) CREAZIONE E VISUALIZZAZIONE DELLA GRIGLIA*)*)
(*(*********************************************************)*)
(**)
(*createEmptyGrid[]:=Table[0,{gridSize},{gridSize}]*)
(**)
(*(*Disegna la griglia dell'utente.Colori:0\[RightArrow]White (vuoto) 1\[RightArrow]Black (nave non attaccata) 2\[RightArrow]Gray (mancato) 3\[RightArrow]Yellow (colpo a segno) 4\[RightArrow]Red (nave affondata)*)*)
(*drawUserGrid[grid_List]:=Module[{cells,col},cells=Flatten[Table[col=Switch[grid[[i,j]],0,White,1,Black,2,Gray,3,Yellow,4,Red,_,White];*)
(*{EdgeForm[Black],col,Rectangle[{j-1,gridSize-i},{j,gridSize-i+1}],Text["",{j-0.5,gridSize-i+0.5}]},{i,1,gridSize},{j,1,gridSize}],1];*)
(*Graphics[cells,Frame->True,ImageSize->Medium]]*)
(**)
(*(*Disegna la griglia del PC.Se debugPC \[EGrave] True,le navi (valore 1) vengono disegnate in Black;*)
(*altrimenti rimangono White (invisibili per l'utente).*)*)
(*drawPCGrid[grid_List]:=Module[{cells,col},cells=Flatten[Table[col=Switch[grid[[i,j]],0,White,1,If[debugPC,Black,White],(*se debugPC=True,la nave si vede in nero*)2,Gray,3,Yellow,4,Red,_,White];*)
(*{EdgeForm[Black],col,Rectangle[{j-1,gridSize-i},{j,gridSize-i+1}],Text["",{j-0.5,gridSize-i+0.5}]},{i,1,gridSize},{j,1,gridSize}],1];*)
(*Graphics[cells,Frame->True,ImageSize->Medium]]*)
(**)
(*(*********************************************************)*)
(*(*3) POSIZIONAMENTO DELLE NAVI*)*)
(*(*********************************************************)*)
(**)
(*placeShipByCoords[oldGrid_List,startBin_String,endBin_String,size_Integer]:=Module[{localGrid=oldGrid,d1,d2,r1,c1,r2,c2,cells,valid=True},d1=BinToDec[startBin];*)
(*d2=BinToDec[endBin];*)
(*If[!(0<=d1<=99&&0<=d2<=99),Return[{False,oldGrid,{}}]];*)
(*{r1,c1}=cellCoords[d1];*)
(*{r2,c2}=cellCoords[d2];*)
(*If[r1!=r2&&c1!=c2,Return[{False,oldGrid,{}}]];*)
(*If[r1==r2,If[Abs[c2-c1]+1!=size,Return[{False,oldGrid,{}}]];*)
(*cells=Table[{r1,c},{c,Min[c1,c2],Max[c1,c2]}],If[Abs[r2-r1]+1!=size,Return[{False,oldGrid,{}}]];*)
(*cells=Table[{r,c1},{r,Min[r1,r2],Max[r1,r2]}]];*)
(*Do[If[localGrid[[cell[[1]],cell[[2]]]]=!=0,valid=False],{cell,cells}];*)
(*If[valid,Do[localGrid[[cell[[1]],cell[[2]]]]=1,{cell,cells}];*)
(*{True,localGrid,cells},{False,oldGrid,{}}]]*)
(**)
(*placeShip[oldGrid_List,{row_,col_},size_Integer,orientation_Integer]:=Module[{localGrid=oldGrid,cells={},valid=True},If[orientation===0,(*orizzontale*)If[col+size-1>gridSize,valid=False,cells=Table[{row,j},{j,col,col+size-1}];*)
(*Do[If[localGrid[[row,j]]=!=0,valid=False],{j,col,col+size-1}]],(*verticale*)If[row+size-1>gridSize,valid=False,cells=Table[{i,col},{i,row,row+size-1}];*)
(*Do[If[localGrid[[i,col]]=!=0,valid=False],{i,row,row+size-1}]]];*)
(*If[valid,If[orientation===0,Do[localGrid[[row,j]]=1,{j,col,col+size-1}],Do[localGrid[[i,col]]=1,{i,row,row+size-1}]];*)
(*{True,localGrid,cells},{False,oldGrid,{}}]]*)
(**)
(*randomPlaceShips[seed_Integer]:=Module[{localGrid,ships={5,4,3,2},placed,attempt,row,col,orientation,shipCells,shipList={}},localGrid=createEmptyGrid[];*)
(*SeedRandom[seed];*)
(*Do[placed=False;attempt=0;*)
(*While[!placed&&attempt<100,orientation=RandomInteger[{0,1}];*)
(*row=RandomInteger[{1,gridSize}];*)
(*col=RandomInteger[{1,gridSize}];*)
(*{placed,localGrid,shipCells}=placeShip[localGrid,{row,col},ship,orientation];*)
(*attempt++];*)
(*If[placed,AppendTo[shipList,shipCells]],{ship,ships}];*)
(*{localGrid,shipList}]*)
(**)
(*(*********************************************************)*)
(*(*4) GESTIONE DEL "SUNK" DELLE NAVI*)*)
(*(*********************************************************)*)
(**)
(*checkSunk[oldGrid_List,shipCells_List]:=Module[{localGrid=oldGrid},(*Se tutte le celle di quella nave sono state colpite (3),diventano 4 (affondate)*)If[And@@(localGrid[[#[[1]],#[[2]]]]===3&/@shipCells),Scan[(localGrid[[#[[1]],#[[2]]]]=4)&,shipCells]];*)
(*localGrid]*)
(**)
(*(*********************************************************)*)
(*(*5) SIMULAZIONE DEGLI ATTACCHI*)*)
(*(*********************************************************)*)
(**)
(*userAttackPC[oldGrid_List,coords:{_,_},pcShips_List]:=Module[{localGrid=oldGrid,i},If[localGrid[[coords[[1]],coords[[2]]]]===1,(*colpo a segno*)localGrid[[coords[[1]],coords[[2]]]]=3;*)
(*For[i=1,i<=Length[pcShips],i++,If[MemberQ[pcShips[[i]],coords],localGrid=checkSunk[localGrid,pcShips[[i]]];*)
(*Break[]]],(*colpo in mare*)If[localGrid[[coords[[1]],coords[[2]]]]===0,localGrid[[coords[[1]],coords[[2]]]]=2]];*)
(*localGrid]*)
(**)
(*pcAttackUser[oldGrid_List,userShips_List,coords:{_,_}]:=Module[{localGrid=oldGrid,i},If[localGrid[[coords[[1]],coords[[2]]]]===1,localGrid[[coords[[1]],coords[[2]]]]=3;*)
(*For[i=1,i<=Length[userShips],i++,If[MemberQ[userShips[[i]],coords],localGrid=checkSunk[localGrid,userShips[[i]]];*)
(*Break[]]],If[localGrid[[coords[[1]],coords[[2]]]]===0,localGrid[[coords[[1]],coords[[2]]]]=2]];*)
(*localGrid]*)
(**)
(*pcAttackTurn[oldGrid_List,userShips_List]:=Module[{localGrid=oldGrid,row,col,tries=0},While[tries<100,row=RandomInteger[{1,gridSize}];*)
(*col=RandomInteger[{1,gridSize}];*)
(*If[MemberQ[{0,1},localGrid[[row,col]]],Break[]];*)
(*tries++];*)
(*localGrid=pcAttackUser[localGrid,userShips,{row,col}];*)
(*{row,col,localGrid}]*)
(**)
(*(*********************************************************)*)
(*(*6) INTERFACCIA DINAMICA DEL GIOCO*)*)
(*(*********************************************************)*)
(**)
(*BattagliaNavaleGame[]:=DynamicModule[{seedInput="",seedVal,userGrid=createEmptyGrid[],pcHiddenGrid=createEmptyGrid[],pcShips={},ships={5,4,3,2},currentShip=1,userShips={},userInput="",turn="user",gameStage="seed",message="Inserisci un seed (numero intero):",attackMessage="",lastAttack={},userAttackCount=0,pcAttackCount=0},Column[{(*Pannello di controllo in alto*)Dynamic[Switch[gameStage,"seed",Column[{Row[{"Seed: ",InputField[Dynamic[seedInput],String,FieldSize->10]}],Button["Conferma Seed",Module[{},If[IntegerQ[ToExpression[seedInput]],(seedVal=ToExpression[seedInput];*)
(*{pcHiddenGrid,pcShips}=randomPlaceShips[seedVal];*)
(*message="Seed confermato. Posiziona la nave di lunghezza "<>ToString[ships[[currentShip]]]<>". Inserisci le celle di INIZIO e di FINE (due binari a 7 cifre separati da '-'):";*)
(*gameStage="placement";*)
(*userInput=""),(message="Inserisci un seed valido!")];*)
(*Null]]}],"placement",Column[{Style[message,Bold,14],Row[{"Input (inizio-fine): ",InputField[Dynamic[userInput],String,FieldSize->40]}],Button["Posiziona Nave",Module[{tokens,startBin,endBin,result,updGrid,shipCells},tokens=StringSplit[userInput,"-"];*)
(*If[Length[tokens]===2&&StringMatchQ[tokens[[1]],RegularExpression["[01]{7}"]]&&StringMatchQ[tokens[[2]],RegularExpression["[01]{7}"]],(startBin=tokens[[1]];*)
(*endBin=tokens[[2]];*)
(*{result,updGrid,shipCells}=placeShipByCoords[userGrid,startBin,endBin,ships[[currentShip]]];*)
(*If[result,(userGrid=updGrid;*)
(*AppendTo[userShips,shipCells];*)
(*currentShip++;*)
(*userInput="";*)
(*If[currentShip>Length[ships],(message="Tutte le navi posizionate. Inizia la battaglia!";*)
(*turn="user";*)
(*userAttackCount=0;*)
(*pcAttackCount=0;*)
(*gameStage="battle"),(message="Nave posizionata. Inserisci la prossima (inizio-fine).")]),message="Posizionamento non valido (allineamento o sovrapposizione). Riprova."]),message="Inserisci due binari a 7 cifre separati da '-'."];*)
(*Null]]}],"battle",Column[{Style["Fase di Battaglia",Bold,16],Style["Turno: "<>turn,Italic,12],Row[{"Inserisci la cella bersaglio per attaccare il PC (binario a 7 cifre): ",InputField[Dynamic[userInput],String,FieldSize->30]}],Button["Attacca (tuo turno)",Module[{d,coords,r,c,newPCGrid,pcRow,pcCol,newUserGrid},(*Controllo se \[EGrave] effettivamente il turno utente*)If[turn=!="user",(attackMessage="Non \[EGrave] il tuo turno!";Return[];),Null];*)
(*(*Controllo che l'input sia un binario a 7 cifre*)If[!StringMatchQ[userInput,RegularExpression["[01]{7}"]],(attackMessage="Inserisci un binario a 7 cifre valido.";Return[];),Null];*)
(*d=BinToDec[userInput];*)
(*coords=cellCoords[d];*)
(*{r,c}=coords;*)
(*(*Controllo se la cella \[EGrave] gi\[AGrave] stata attaccata prima*)If[!MemberQ[{0,1},pcHiddenGrid[[r,c]]],(attackMessage="Hai gi\[AGrave] attaccato questa cella.";Return[];),Null];*)
(*(*Attacco l'utente->PC*)newPCGrid=userAttackPC[pcHiddenGrid,coords,pcShips];*)
(*pcHiddenGrid=newPCGrid;*)
(*userAttackCount++;*)
(*attackMessage="Hai attaccato la cella: "<>ToString[coords];*)
(*(*Se tutte le navi del PC sono state colpite dopo un certo numero di turni,dichiaro la vittoria dell'utente*)If[userAttackCount>=15&&pcAttackCount>=15&&Count[Flatten[pcHiddenGrid],1]==0,(message="Hai vinto!";gameStage="end";Return[];),Null];*)
(*(*Passo la mano al PC*)turn="pc";*)
(*{pcRow,pcCol,newUserGrid}=pcAttackTurn[userGrid,userShips];*)
(*userGrid=newUserGrid;*)
(*pcAttackCount++;*)
(*attackMessage=attackMessage<>" | Il PC ha attaccato "<>ToString[{pcRow,pcCol}];*)
(*(*Controllo se il PC ha affondato tutte le navi utente*)If[userAttackCount>=15&&pcAttackCount>=15&&Count[Flatten[userGrid],1]==0,(message="Il PC ha vinto!";gameStage="end";Return[];),Null];*)
(*turn="user";*)
(*userInput="";*)
(*Null]],Dynamic[attackMessage]}],"end",Column[{Style[message,Bold,16]}],_,Null]],Spacer[20],(*Layout con le due griglie affiancate in basso*)Dynamic[Row[{Column[{"Griglia Utente:",drawUserGrid[userGrid]}],Spacer[50],Column[{"Griglia PC:",drawPCGrid[pcHiddenGrid]}]}],TrackedSymbols:>{userGrid,pcHiddenGrid}]}],(*Qui la parte fondamentale:salviamo le definizioni delle funzioni per la dinamica*)SaveDefinitions->True];*)
(**)
(*End[];*)
(*EndPackage[];*)
(**)
